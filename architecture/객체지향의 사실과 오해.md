# 도입

- 객체지향이라는 단어는 오랜 역사와 성숙도에도 불구하고 소프트웨어 개발 커뮤니티에서 여전히 수많은 오해와 논쟁을 불러일이키곤 합니다. 안타깝게도 대부분의 사람들은 여전히 객체지향이란 무엇인가에 대해 자신있게 대답하지 못하는 것 같습니다. 객체지향으로 향하는 첫 걸음은 클래스가 아니라 객체를 바라보는 것에서 시작합니다.

# 협력하는 객체들의 공동체

- 객체지향이라고 불리는 새로운 세상의 문을 연 대부분의 사람들은 “객체지향이란 실세계를 직접적이고 직관적으로 모델링할 수 있는 패러다임”이라는 설명과 마주하게 된다. 하지만 애플리케이션을 개발하면서 객체에 직접적으로 대응되는 실세계의 사물을 발견할 확률은 그다지 높지 않다. 심지어 소프트웨어가 반영해야 하는 객관적인 실세계가 존재한다는 아이디어조차도 논란의 여지가 있는 철학적 근거를 기반으로 한다.
- 사람들은 스스로 해결하지 못하는 문제와 마주치면 문제 해결에 필요한 지식을 알고 있거나 서비스를 제공해 줄 수 있는 사람에게 도움을 `요청(Request)`한다. 요청을 받은 사람은 주어진 책임을 다하면서 필요한 지식이나 서비스를 제공한다. 즉, 다른 사람의 요청에 `응답(Response)`한다.
- 역할이라는 단어는 의미적으로 책임이라는 개념을 내포한다.
- 사람들이 협력을 위해 특정한 역할을 맡고 역할에 적합한 책임을 수행한다는 사실은 몇 가지 중요한 개념을 제시한다.
  - 여러 사람이 동일한 역할을 수행할 수 있다: 손님 입장에서 자신이 주문한 커피를 마실 수만 있다면 어떤 캐시어가 주문을 받는지 중요하지 않다. 캐시어 입장에서 자신이 전달한 주문 내역에 맞게 커피를 제조할 수 있다면 어떤 바리스타가 커피를 제조하더라도 크게 상관하지 않는다.
  - 역할은 대체 가능성을 의미한다: 손님 입장에서 캐시어는 대체가능(Substitutable)하다.
  - 책임을 수행하는 방법은 자율적으로 선택할 수 있다: 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 `다형성(Polymorphism)`이라고 한다.
  - 한 사람이 동시에 여러 역할을 수행할 수 있다: 한 사람이 캐시어와 바리스타의 역할을 동시에 수행하는 것도 가능하다.
- 앞에서 사람이라는 단어를 객체로, 에이전트의 요청을 메시지로, 에이전트가 요청을 처리하는 방법을 메서드로 바꾸면 마법처럼 대부분의 설명을 객체지향이라는 문맥으로 옮겨올 수 있다. 이것이 바로 많은 사람들이 객체지향을 설명하기 위해 실세계의 모방이라는 은유를 차용하는 이유다.
- 일상생활에서 목표는 사람들의 협력을 통해 달성되며, 목표는 더 작은 책임으로 분할되고 책임을 수행할 수 있는 적절한 역할을 가진 사람에 의해 수행된다. 결론적으로 시스템은 역할과 책임을 수행하는 객체로 분할되고 시스템의 기능은 객체 간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현된다.
- 객체는 충분히 ‘협력적’이어야 한다. 모든 것을 스스로 처리하려고 하는 전지전능한 객체(God Object)는 내부적인 복잡도에 의해 자멸하고 만다. 객체는 다른 객체의 명령에 복종하는 것이 아니라 요청에 응답할 뿐이다. 객체는 자율적이어야 한다. 다른 객체의 요청에 따라 행동하지만 최대한 스스로의 판단에 따라 결정하고 행동한다.
- 객체가 협력에 참여하는 과정 속에서 스스로 판단하고 스스로 결정하는 자율적인 존재로 남기 위해서는 필요한 행동과 상태를 함께 지니고 있어야 한다. 객체의 자율성은 객체의 내부와 외부를 명확하게 구분하는 것으로 부터 나온다.
- 앨런 케이(Alan Kay)와 같은 객체지향 선구자들의 초기 의도와 달리 대부분의 사람들은 객체지향을 클래스를 지향하는 것으로 생각했다. 클래스는 객체들의 협력 관계를 코드로 옮기는 도구에 불과하다. 클래스는 객체지향 세계의 도시전설이다.

# 이상한 나라의 객체

- 주문과 계좌 이체는 비록 물리적인 실체는 존재하지 않더라도 인간이 쉽게 구분하고 하나의 단위로 인지할 수 있는 개념적인 객체의 일종이다.
- 현실 세계와 소프트웨어 세계 사이의 유사성은 여기까지일 뿐이다. 객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 창조하는 것이다. 현실 세계의 전등은 사람의 손길 없이는 스스로 불을 밝힐 수 없지만 소프트웨어 세계의 전등은 외부의 도움 없이도 스스로 전원을 켜거나 끌 수 있다.
- 그러나 세상에 존재하는 모든 것들이 객체인 것은 아니다. 분명하게 인식할 수 있음에도 객체의 영역에 포함시킬 수 없는 것들도 존재한다. 앨리스의 키와 위치는 객체가 아니다. 단순한 값은 객체가 아니지만 객체의 상태를 표현하기 위한 중요한 수단이다.
- 객체와 객체 사이의 의미있는 연결을 링크(Link)라고 한다. 객체와 객체 사이에는 링크가 존재해야만 요청을 보내고 받을 수 있다. 링크는 객체가 다른 객체를 참조할 수 있다는 것을 의미하며, 이것은 일반적으로 한 객체가 다른 객체의 식별자를 알고 있는 것으로 표현된다.
- 객체가 취하는 행동은 객체 자신의 상태를 변경시킨다. 객체의 행동에 의해 객체의 상태가 변경된다는 것은 행동이 부수 효과(Side Effect)를 초래한다는 것을 의미한다.
- 현실 속에서 앨리스는 스스로 음료를 마시는 능동적인 존재지만 음료는 스스로는 아무것도 할 수 없는 수동적인 존재다. 그러나 객체지향의 세계에서 모든 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다.
- 모든 객체가 식별자를 가진다는 것은 반대로 객체가 아닌 단순한 값은 식별자를 가지지 않는다는 것을 의미한다. 값(Value)은 숫자, 문자열, 날짜, 시간, 금액 등과 같이 변하지 않는 양을 모델링한다. 흔히 값의 상태는 변하지 않기 때문에 불변 상태(Immutable State)를 가진다고 말한다.
- 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동등성(Equality)이라고 한다. 상태를 이용해 동등성을 판단할 수 있는 이유는 값의 상태가 변하지 않기 때문이다. 반면 객체는 가변 상태(Mutable State)를 가진다고 말한다. (중략) 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 동일성(Identical)이라고 한다.
- 일반적으로 객체의 상태를 조회하는 작업을 쿼리(Query)라고 하고 객체의 상태를 변경하는 작업을 명령(Command)이라고 한다. 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다.
- 현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은 무엇일까? 그것은 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다는 것이다. 레베카 워프스브록은 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 `의인화(Anthropomorphism)`라고 부른다.
- 현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 은유(Metaphor)다. 따라서 소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있으며, 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다. 바로 이러한 이유로 모든 객체지향 지침서에서는 현실 세계인 도메인에서 사용되는 이름을 객체에게 부여하라고 가이드하는 것이다.

# 타입과 추상화

- 추상화의 목적은 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복하는 것이다.
- 객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.
- 타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.
- 애플리케이션 안에서 타입이 없는 메모리 내부의 값을 다루다 보면 수많은 오해와 시행착오에 부딪히게 된다. 메모리 안에 저장된 ‘10010001’이라는 값은 숫자인가, 문자인가, 아니면 특정한 메모리 상의 주소인가? 타입 시스템의 목적은 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하는 것이다.
- 실제로 객체지향 프로그램을 작성할 때 우리는 객체를 일종의 데이터처럼 사용한다. 그렇다면 객체는 데이터인가? 그렇지 않다. 다시 한번 강조하지만 객체에서 중요한 것은 객체의 행동이다. 상태는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일 뿐이다. 결론적으로 객체의 타입을 결정하는 것은 객체의 행동뿐이다.
- 타입이 데이터가 아니라 행동에 의해 결정된다는 사실은 객체지향 패러다임을 특징 짓는 중요한 몇 가지 원리와 원칙에 의미를 부여한다. 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다. 이것은 다형성에 의미를 부여한다. 다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜻한다.
- 중요한 것은 객체지향에서 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 행동이라는 것이다. 트럼프와 트럼프 인간 모두 납작 엎드릴 수 있고 뒤집어질 수 있다. 거기에 더해 트럼프 인간은 추가적인 행동을 더 할 수가 있는데 바로 걸을 때마다 몸이 종이처럼 좌우로 펄럭일 수 있다는 것이다.
- 왜 타입을 사용해야 하는가? 객체지향은 객체를 지향하는 것이므로 객체만 다루면 되지 않는가? 타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기가 너무 어렵기 때문이다.
- 객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐를 객체의 스냅샷(Snapshot)이라고 한다. UML에서 스냅샷은 객체 다이어그램이라고도 불린다.
- 동적 모델과 정적 모델의 구분은 실제로 프로그래밍이라는 행위와도 관련이 깊다. 여러분이 객체지향 프로그래밍 언어를 이용해 클래스를 작성하는 시점에는 시스템을 정적인 관점에서 접근하는 것이다. 그러나 실제로 애플리케이션을 실행해 객체의 상태 변경을 추적하고 디버깅하는 동안에는 객체의 동적인 모델을 탐험하고 있는 것이다. 여러분이 훌륭한 객체지향 프로그래머라면 애플리케이션의 동적인 관점과 정적인 관점을 모두 다뤄야 한다는 사실을 쉽게 이해할 수 있을 것이다.

# 역할, 책임, 협력

- 요약하면 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.
  - `덕 타이핑(Duck Typing)`의 이론적 배경이다.
- 테스트 주도 개발은 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각하라고 충고한다. 그러나 이 같은 종류의 충고는 역할, 책임, 협력의 관점에서 객체를 바라보지 않을 경우 무의미하다. 가끔 테스트 주도 개발이 어떤 식으로 작동한는지 전혀 이해하지 못하겠다고 어려움을 토로하는 사람들을 만나게 된다. 이야기를 나누다 보면 대부분의 사람들이 책임과 협력의 관점에서 객체를 바라보는 훈련이 부족하다는 것을 깨닫게 된다.
- 테스트 주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다. 테스트에 필요한 간접 입력 값을 제공하기 위해 스텁(Stub)을 추가하거나 간접 출력 값을 검증하기 위해 목 객체(Mock Object)를 사용하는 것은 객체와 협력해야 하는 협락자에 관해 고민한 결과를 코드로 표현한 것이다.

# 책임과 메시지

- 객체지향 공동체를 구성하는 기본 단위는 ‘자율적’인 객체다. 객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이다. 요청을 처리하기 위해 객체가 수행하는 행동을 책임이라고 한다.
- 추상적이고 포괄적인 책임은 협력을 좀 더 다양한 환경에서 재사용할 수 있도록 유연성이라는 축복을 내려준다. 그러나 책임은 협력에 참여하는 의도를명확하게 설명할 수 있는 수준 안에서 추상적이어야 한다. 자율적인 책임의 특징은 ‘어떻게(How)’가 아니라 ’무엇(What)’을 해야하는가를 설명한다는 것이다.
- 메시지를 처리하기 위해 내부적으로 선택하는 방법을 `메서드`라고 한다. 객체는 메시지를 수신하면 먼저 해당 메시지를 처리할 수 있는지 여부를 확인한다. 메시지를 처리할 수 있다고 판단되면 자신에게 주어진 책임을 다하기 위해 메시지를 처리할 방법인 메서드를 선택하게 된다. 객체지향 프로그래밍 언어에서 메서드는 클래스 안에 포함된 함수 또는 프로시저를 통해 구현된다.
- 메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 사실은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분 짓는 핵심적인 특징 중 하나다.
- 일단 메시지와 메서드의 차이와 관계를 이해하고 나면 객체지향의 핵심 개념인 다형성을 쉽게 이해할 수 있다. 다형성이란 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것을 의미한다. 서로 다른 객체들이 다형성을 만족시킨다는 것은 객체들이 동일한 책임을 공유한다는 것을 의미한다. 다형성에서 중요한 것은 메시지 송신자의 관점이다. 메시지 수신자들이 동일한 오퍼레이션을 서로 다른 방식으로 처리하더라도 메시지 송신자 관점에서 이 객체들은 동일한 책임을 수행하는 것이다.
- 송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다.
- 클래스 기반의 객체지향 언어를 사용하는 대부분의 사람들은 객체지향 애플리케이션을 클래스의 집합으로 생각한다. 프로그래머 입장에서 클래스는 실제로 볼 수 있고 수정할 수 있는 구체적인 존재다. 대부분의 입문자들은 클래스 간의 상속 관계가 객체지향 설계를 가치 있게 만드는 핵심적인 메커니즘이라고 배운다.
- 클래스가 코드를 구현하기 위해 사용할 수 있는 중요한 도구인 것은 사실이지만 객체지향의 강력함은 클래스가 아니라 객체들이 주고받는 메시지로부터 나온다. 실제로 애플리케이션을 살아있게 만드는 것은 클래스가 아니라 객체다. 그리고 이런 객체들의 윤곽을 결정하는 것이 바로 객체들이 주고받는 메시지다.
- 책임 주도 설계의 핵심은 어떤 행위가 필요한지를 먼저 결정한 후에 이 행위를 수행할 객체를 선택하는 것이다. 이 과정을 흔히 `What/Who 사이클`이라고 한다. 먼저 어떤 행위를 수행할 것인지를 결정한 후에 누가 그 행위를 수행할 것인지를 결정해야 한다는 것이다. 여기서 어떤 행위가 바로 메시지다.
- 메시지를 먼저 결정하고 객체가 메시지를 따르게 하는 설계 방식은 객체가 외부에 제공하는 인터페이스가 독특한 스타일을 따르게 한다. 이 스타일을 `묻지 말고 시켜라(Tell, Don’t Ask)` 스타일 또는 데메테르 법칙이라고 한다.
- 송신자는 수신자가 어떤 객체인지 모르게 때문에 객체에 관해 꼬치꼬치 캐물을 수 없다. 단지 송신자는 수신자가 어떤 객체인지는 모르지만 자신이 전송한 메시지를 잘 처리할 것이라는 것을 믿고 메시지를 전송할 수 밖에 없다. 이런 스타일의 협력 패턴은 ‘묻지 말고 시켜라’라는 이름으로 널리 알려져 있다. 객체는 다른 객체의 상태를 묻지 말아야 한다.
- 객체지향의 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어는 구현(Implementation)이다.

# 객체 지도

- 소프트웨어가 사용자에게 가치 있는 이유는 사용자가 필요로 하는 기능을 제공하기 때문이다. 훌륭한 기능이 훌륭한 소프트웨어를 만드는 충분조건이라고 한다면 훌륭한 구조는 훌륭한 소프트웨어를 만들기 위한 필요조건이다.
- 사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 한다. 도메인 모델에서 모델이란 대상을 단순화해서 표현한 것이다. 모델을 사용하면 현재의 문제와 관련된 측명은 추상화하고 그 밖의 관련 없는 세부 사항에 대해서는 무시할 수 있다. 도메인 모델은 단순히 다이어그램이 아니다. 도메인 모델은 이해관계자들이 바라보는 멘탈 모델(Mental Model)이다.
- 유즈케이스는 설계 기법도, 객체지향 기법도 아니다. 유즈케이스가 단지 사용자가 바라보는 시스템의 외부 관점만을 표현한다는 점에 주목하라.
- 유즈케이스에서 출발해 객체들의 협력으로 이어지는 일련의 흐름은 객체 안에 다른 객체를 포함하는 재귀적 합성이라는 객체지향의 기본개념을 잘 보여준다. (중략) 처음에 나는 전체를 완전한 하나의 컴퓨터로 간주했고, 사람들이 왜 컴퓨터를 자료구조와 프로시저라는 더 약한 개념으로 분할하려고 하는지 그 이유가 궁금했다. 시분할이 시작한 것처럼 왜 컴퓨터를 더 작은 컴퓨터로 나누지 않는가[Kay, 1993]

---

[1] 객체지향의 사실과 오해: 역할, 책임, 협력 관점에서 본 객체지향, 위키북스, 조영호
