# 지속적 통합의 배경: 원칙과 실천 방법

## 변경할 때마다 소프트웨어를 빌드하기

<aside>
💡 **빌드란?**
빌드는 컴파일(또는 동적 언어에서와 같은 변형된 형태)보다 훨씬 많은 것을 의미합니다. 빌드에는 컴파일과 테스트, 검사, 배포 등의 과정들이 포함될 수 있습니다.

</aside>

### CI 시나리오

`CI 시나리오`는 개발자가 소스 코드 저장소에 코드를 커밋할 때 시작됩니다. 지속적인 통합 시나리오라면 일반적인 각 단계는 다음과 같습니다.

1. 개발자가 버전 관리 저장소에 코드를 커밋해 넣습니다. 그사이, 통합 빌드 컴퓨터에 설치된 CI 서버가 변경 사항이 없는지 이 저장소를 계속 확인합니다. 이를 테면, `폴링(Polling)` 할 수 있습니다.
2. 커밋이 되면 곧이어, CI 서버가 버전 관리 저장소에서 변경 내역을 감지해냅니다. 그리고 CI 서버는 저장소에서 최신 소스 코드 복사본을 가져와서 빌드 스크립트를 실행하고 소프트웨어를 통합합니다.
3. CI 서버는 지정된 프로젝트 구성원들에게 이메일로 빌드 결과를 보냄으로써 `피드백`을 줍니다.
4. CI 서버는 버전 관리 저장소에 변경 사항이 들어왔는지 계속해서 폴링합니다.

### CI의 도구와 참가자

- 개발자
  - 작업 내용과 관련된 수정 작업이 끝나면, 개발자는 개인 빌드를 수행하고, 그러고 나서 변경 내역을 버전 관리 저장소에 커밋합니다. 이 과정은 언제라도 발생할 수 있으며, CI 프로세스의 이후 과정엔 영향을 주지 않습니다.
  - 소프트웨어 결함은 의심할 여지 없이 어느 시점엔가 코드 베이스에 슬그머니 들어올 것이기 때문이죠. 빌드를 지속적으로 하려는 것도 **피드백을 신속히 받으면 개발 생명주기 내내 문제를 발견하고 해결**할 수 있기 때문입니다.
- 버전 관리 저장소
- 지속적인 통합 서버
  - 지속적인 통합 서버는 버전 관리 저장소에 변경 사항이 커밋되어 들어올 때마다 통합 빌드를 돌립니다.
  - 이뿐만 아니라 지속적인 통합 서버는 보통 빌드 결과를 게시하는 편리한 `대시보드`를 제공합니다.
- 빌드 스크립트
  - 빌드 스크립트는 코드 컴파일 및 검사, 배포 등의 작업들을 자동화하는 배치 스크립트를 말합니다.
- 피드백 메커니즘
  - 지속적인 통합을 사용하는 주 목적 중 하나는 통합 빌드 시, 이에 대한 피드백을 즉시 주는 것입니다. 최신 빌드에 뭔가 문제가 있다면 최대한 빨리 그 사실을 알아야 하니까요.
- 통합 빌드 머신
  - 통합 빌드 머신은 소프트웨어를 빌드하는 것을 그 유일한 존재 목적으로 삼는 별도의 컴퓨터를 말합니다.

### 지속적인 통합의 특징

- 소스 코드 컴파일
- 데이터베이스 통합
- 테스트
  - 자동화되고 지속적인 테스트가 구비되어 있지 않은 CI는 CI가 아닙니다.
- 검사(Inspection)
  - 자동화된 코드 검사(이를테면 `정적 분석`이나 `동적 분석`)는 여러 코딩 규칙을 강제함으로써 소프트웨어의 품질을 높이는 데 사용할 수 있습니다.
- 배포
- 문서화와 피드백
  - 좋은 CI 시스템의 핵심적인 특징은 속도입니다. 지속적인 통합 시스템의 정수는 개발자와 프로젝트 이해관계자들에게 시의 적절하게 `피드백`을 제공하는 겁니다. 지속적인 통합 시스템에 이것저것 끼워 넣다보면(완벽하게 하려고), 한 주기를 끝마치는데 말도 안되는 시간이 걸리기 쉽습니다.

## 지속적인 통합 도입하기

<aside>
💡 억측은 일을 망치는 근원이다 - 웨던의 판단 보류의 법칙

</aside>

지속적인 통합은 개발의 근본에 관한 겁니다. 소프트웨어 개발에서 눈에 띄는 가장 영광스러운 작업은 아닐지 몰라도, 소프트웨어를 통합하는 일은 오늘날의 복잡한 프로젝트에선 극히 중요합니다. 지속적인 통합을 단순히 각 소프트웨어 컴포넌트를 한데 모으는 과정에 불과하다고 생각하는 사람도 있지만, 우리는 **CI를 소프트웨어 개발의 핵심**이라고 생각합니다.

### 지속적인 통합과 함께하는 하루 일과

- 모니터는 몇 분 전에 CI 서버가 마지막 통합 빌드를 성공리에 마쳤음을 보여줍니다. 모니터는 가장 최근의 품질 목록을 도표로 보여주는데, 여기에는 코딩 및 설계 표준 준수, 코드 중복 등이 포함됩니다.
- 이 토론이 있은 후, 톰과 리사는 코드 적용범위가 85% 이하이면 통합 빌드를 실패 처리하기로 결정했습니다.
  - 리사: 오늘 아침에 톰이 변경한 코드가 마지막 빌드를 깨뜨린 듯한데요.
  - 톰: 흠…하지만 테스트를 돌려봤는걸요.
  - 리사: 아, 시간이 부족해서 테스트를 작성하지 못했어요.
  - 톰: 우리가 수립했던 코드 적용범위 메트릭을 지키고 있어요?

### 지속적인 통합에는 어떤 가치가 있을까요?

- 위험을 줄여준다.
  - 결함을 발견하고 보다 조기에 수정합니다.
  - 소프트웨어 건강 상태를 측정할 수 있습니다.
  - 똑같은 프로세스와 스크립트를 사용하여 가정을 줄입니다.
- 반복적인 수작업을 줄여준다.
  - 프로세스가 매번 동일한 방식으로 돌아갑니다.
  - 순서에 맞춰 프로세스가 수행됩니다.
- **언제 어느 때라도 배포할 수 있는 소프트웨어를 생성**해낸다.
  - 이것이야말로 CI의 가장 분명한 이점이라고 하겠습니다.
  - 배포 가능한 소프트웨어야말로 고객이나 사용자 같은 외부인에게는 가장 손에 잘 잡히는 자산입니다. 이 점이 얼마나 중요한지는 아무리 강조해도 모자랍니다.
- 프로젝트 가시성을 보다 좋게 해준다.
- 개발 팀이 소프트웨어 제품에 대해 보다 큰 자신감을 갖게 해준다.

### 지속적인 통합을 왜 도입하지 못할까요?

- CI 시스템을 유지보수하기 위한 추가적인 과부하
- 변경할 게 많음
  - 먼저 빌드와 테스트를 좀더 낮은 빈도로 실행하게 하고 나서, 사람들이 그 결과에 익숙해지면 주기를 짧게 하는 겁니다.
- **빌드 실패 횟수가 너무 많음**
- 추가적인 하드웨어 및 소프트웨어 비용
- **개발자들이 이런 활동을 수행해야 합니다.**

### 지속적인 통합을 도입하려면 어떻게 해야 할까요?

지속적인 통합은 스크립트 몇 개를 긁어 모아서 상시 돌리는 단순한 프로세스가 아닙니다. 그 스크립트를 버전 관리 저장소에 추가하고 빌드 프로세스의 실질적인 일부로 만들어야 합니다.

### 언제, 어떻게 프로젝트에 지속적인 통합을 도입해야 할까요?

목표는 시스템에 변경사항이 있을 때마다 빌드를 돌리는 것이더라도, 일단은 일일 빌드를 돌리는 것부터 시작함으로써 조직 내에 실천 방법이 스며들게 하는 편이 낫습니다. 잊지 마세요. CI는 단순한 기술적 성취를 뜻하는 것이 아닙니다. **CI는 `조직과 문화의 성취`입니다.**

### 지속적인 통합은 다른 개발 실천 방법을 어떻게 보완할까요?

CI 실천 방법은 개발자 테스트 및 코딩 표준 준수, 리팩토링, 작은 릴리즈 등의 소프트웨어 개발 실천 방법을 보완해주는 역할을 합니다. 여러분이 RUP, XP, SCRUM, Crystal 또는 다른 개발방법론을 사용하더라도 상관 없습니다.

### 지속적인 통합과 나

- 코드를 자주 커밋하세요.
- 깨진 코드를 커밋해선 안됩니다.
- 빌드가 깨지면 즉시 고치세요.
- 자동화된 개발자 테스트를 작성하세요.
- 테스트와 검사는 모두 통과해야 합니다.
- 개인 빌드를 돌리세요.
- 깨진 코드는 가져오지 마세요.

## 지속적인 통합을 이용해 위험 줄이기

<aside>
💡 품질이란 누가 보지 않을 때에도 제대로 돌아가는 걸 뜻한다 - 헨리 포드

</aside>

### 위험요소

- 배포 가능한 소프트웨어의 부재
  - **내 컴퓨터에선 되는데요?**
  - IDE와 빌드 프로세스가 서로 강하게 얽혀 있으면 안된다.
  - 통합 빌드 머신을 통해 동일한 프로세스와 동일한 머신에 결함을 발견해야 한다.
- 뒤늦은 결함 발견
- 프로젝트 가시성의 부재
- 저품질의 소프트웨어

## 변경될 때마다 소프트웨어를 빌드하기

<aside>
💡 이 빌어먹을 우주는 조각조각 내서 다시 구축해야 한다 - 헨리 밀러

</aside>

어떨 때 보면 개발자는 고객의 신발은 빈틈없이 고쳐주면서, 정작 자기 아이들의 신발을 수선하는 건 잊어버리는 구두 수성공 같습니다. 우리는 사용자를 위해 프로세스를 자동화하는 애플리케이션을 창조하지만, **정작 자신의 프로세스를 자동화여 소프트웨어 개발을 거들 생각은 못합니다.**

### 빌드를 자동화하기

마틴 파울러는 “필요한 거라면 뭐든지 소스 관리 저장소에 넣어뒀다 빼내서 쓰세요. 그래야 **명령어 하나로** 시스템 전체를 빌드할 수 있습니다”라고 말했습니다.

### IDE에서 빌드 스크립트를 분리해내기

빌드 스크립트와 IDE를 결합시키는 일만큼은 피해야 합니다. IDE는 빌드 스크립트에 의존해도 되지만, 빌드 스크립트는 IDE에 의존해선 안됩니다.

### 빌드 유형과 메커니즘

- 개인 빌드
  - 개발자는 저장소에 코드를 커밋하기 전에 개인 빌드부터 돌려볼 겁니다. 개인 빌드를 돌림으로써 빌드가 깨지지 않게 할 수 있습니다.
- 통합 빌드
  - 이상적으로는 통합 빌드를 별도의 전용 컴퓨터에서 돌려야 합니다.
- 빌드 메커니즘
  - 주문형
  - **일정 기반**
  - **변경 사항을 폴링하기**
  - **이벤트 주도**

### 빌드 시간을 짧게 만들기

`익스트림 프로그래밍` 2판에서 켄드 벡은 경험에 따르면 통합 빌드가 10분 내로 끝나게 유지하는게 좋다고 말했습니다.

- 증분 빌드(IncreBuild)는 바뀐 파일만 컴파일하고 다시 생성합니다. 이는 위험할 수 있는데, 증분 빌드를 구현한 방식에 따라서는 지속적인 통합의 혜택을 모두 누리지 못할 수도 있기 때문입니다.

# 완전한 기능을 갖춘 지속적인 시스템 만들기

## 지속적인 테스트

<aside>
💡 연습이 완벽을 낳는다 - 영국 속담

</aside>

시스템 공학의 원리에 따르면 선형 시스템의 신뢰도는 각 시스템 컴포넌트의 신뢰도를 곱한 값이라고 합니다. 세 개의 컴포넌트의 신뢰도가 90%라면 시스템 전체의 신뢰도는 90%가 아니라 73%입니다. 73%만큼 실뢰할 수 있는 다리를 차를 몰고 건너보신 적이 있나요?

**`객체` 수준에서 최저 수준의 신뢰도를 보장하거나 측정해내지 못한다면, 시스템 수준에서는 말할 것도 없습니다.** 하지만 이것이 우리, 소프트웨어 산업계가 소프트웨어를 구축하고 인도해왔던 주된 방식이었습니다. **설계하고, 만들고, 그런 후 벽 너머 품질 보증 팀에게 던져줘라.**

만약 진실로 신뢰할만한 소프트웨어 시스템을 만들고자 한다면, 최소한 객체 수준에서 신뢰도를 보장해야만 하는데, 이는 성공적인 단위 테스트를 통해서만 이뤄낼 수 있습니다. **단위 테스트는 개발 주기 초반(첫날에라도)에 만들고 돌릴 수 있습니다.**

### 시간이 덜 걸리는 테스트부터 실행하기

단위 테스트를 가장 자주 실행하고 컴포넌트 테스트, 시스템 테스트, 기능 테스트는 2차 빌드 때 돌리거나 일정 주기마다 돌려도 됩니다.

### 단위 테스트

- **진정한 단위 테스트라면 실행부터 완료까지 눈깜짝할 사이에 끝나야 합니다.**
- 테스트 케이스가 실패하지 않게 됐다고 해서 제대로 됐다는 말은 아닙니다. 단지 실패하지 않을 뿐이죠. 진정으로 결함을 고치고자 한다면 테스트를 깨뜨려야 합니다.

### 테스트 케이스 하나에 어썰트(assert) 하나로 제한하기

- 빡빡한 일정을 따라 힘차게 개발하다가 행복한 시간이 임박해오면, 테스트 케이스 하나에 모든 걸 집어넣고 일단 돌려보고픈 유혹이 듭니다.
- 첫 번째 어썰트가 실패하면 실패한 그 지점부터 테스트 케이스 전체가 버려집니다. 이는 뒤이은 어썰트 두 개는 실행되지도 않을 것이란 뜻입니다.

## 지속적인 검사

<aside>
💡 다른 이의 머리를 이용해 자기 일을 해내는 사람이야말로 위대한 사람이다 - 돈 피아트

</aside>

### 검사와 테스트는 무엇이 다를까요?

**테스트는 동적인 활동이며, 소프트웨어를 직접 실행시켜서 그 기능성을 확인하는 활동**입니다. **검사는 미리 정의한 규칙 집합에 따라 코드를 분석하는 활동**입니다.

### 검사기를 얼마나 자주 돌려야 할까요?

- 결함이 침투하기 전에 발견하세요. 자동화된 코드 포맷팅, 사용하지 않는 변수, 미숙한 언어 사용 등을 도와주는 내장 검사 기능을 갖춘 IDE가 많습니다.

### 중복 코드를 줄이기

프로그래밍 구조물(절차적 프로그래밍, 객체 지향적 프로그래밍, 그리고 더 최근에는 관점 지향 프로그래밍)에 이르는 진보는 모두 코드를 중복시켜야 할 필요성을 줄이기 위한 노력이었습니다.

## 지속적인 배포

<aside>
💡 제대로 하려면 직접 하라 - 영국 속담

</aside>

사람들이 제정신을 못 차리고 잠도 자지 못하고 점점 머리카락이 새하얘져 가는데, 그런데도 여전히 최종 사용자는 새 릴리즈를 받지 못합니다. **작동하는 소프트웨어를 효율적으로 만들어내는 것이야말로 직업 소프트웨어 개발자가 존재하는 이유**입니다.

### 작동하는 소프트웨어를 언제, 어느 곳에서든 릴리즈하기

배포할 때 쓰는 명령어는 `ant deploy`만큼 간단해야 합니다.

### 저장소 안의 자산에 꼬리표 붙이기

### 깨끗한 환경 만들기

- Docker

### 테스트를 모두 돌리기

어떤 개발 단계에서는 특정 묶음의 테스트만 돌려도 될지 모르지만, 배포 빌드를 패키징하기 전에는 모든 테스트를 반드시 돌려보고 통과시켜야 합니다. CI 접근 방법은 **테스트가 100% 성공하도록** 요구 사항을 자동화하라고 말합니다. 이렇게 일하면, **어느 테스트가 실패했는지 그리고 왜 실패했는지에 대해 데이터를 얻을 수 있습니다.**

### 릴리즈를 롤백할 수 있는 능력 확보하기

궁극적으로 배포를 원래대로 되돌리는 능력을 확보해야지만 개발을 효율적으로 할 수 있습니다.

## 지속적인 피드백

<aside>
💡 일반적으로 살아가는데 있어 가장 성공적인 사람은 최고의 정보를 가진 사람이다 - 벤자민 디즈렐리

</aside>

피드백은 통합 버튼의 핵심입니다. **피드백이 없이는 CI의 어떤 측면들도 쓸모가 없습니다.** 빌드 속도를 높이고 빌드 실패가 빨리 드러나게 하려는 까닭도 피드백 때문입니다.

### 정보 과부하를 경계하세요

프로젝트 참여자 모두에게 피드백을 보내다 보면 사람들이 그 정보를 `무시`하게 됩니다.

# 지속적인 통합의 미래

오랫동안 지속적인 통합을 수행한 여러 사람에게서 전형적으로 두 가지 중요한 제약조건이 있다는 걸 알게 되었습니다.

- **어떻게 해야 빌드가 깨지지 않을까?**
- **어떻게 해야 빌드가 빨리 돌아가게 할 수 있을까?**

## CI 도구 평가하기

<aside>
💡 기술을 갈고 닦고자 하는 장인이라면 우선 도구부터 갈아야 한다 - 중국 속담

</aside>

### 도구를 평가할 때 고려할 점

도구를 비교하는 대화는 곧잘 실용적인 측면을 넘어 종교적인 논쟁처럼 들릴 지경이 되곤합니다.
