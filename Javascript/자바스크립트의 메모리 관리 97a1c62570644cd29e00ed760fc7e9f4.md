# 자바스크립트의 메모리 관리

생성일: 2023년 3월 14일 오후 9:43
tags: 메모리, 자바스크립트

# 자바스크립트의 메모리 관리

메모리 생존주기는 프로그래밍 언어와 관계없이 비슷하다.

- 값 초기화: 프로그래머를 할당 문제로 괴롭히지 않기 위해서, 자바스크립트는 값을 선언할 때 자동으로 메모리를 할당한다.
- 값 사용: 변수나 객체의 속성의 값을 읽고 쓰거나 함수 호출 시 함수에 인수를 전달하여 수행할 수 있다.
- 할당된 메모리가 더 이상 필요없을 때 해제하기: 이 단계에서 **대부분의 문제가 발생**한다. 할당된 메모리가 더 이상 필요없을 때를 알아내기가 어렵기 때문이다. 저수준 언어에서는 개발자가 직접 결정하고 해제한다.

### 가비지 콜렉션

자바스크립트와 같은 고수준 언어들은 `가비지 콜렉션(GC)`라는 자동 메모리 관리 방법을 사용한다. 가비지 콜렉터의 목적은 메모리 할당을 추적하고 할당된 메모리 블록이 더 이상 필요하지 않게 되었는지를 판단하여 회수하는 것이다. 하지만 이러한 방법이 궁극의 방법은 아니다. 왜냐하면 어떤 메모리가 필요한지 아닌지를 판단하는 것은 **여전히 비결정적 문제**이기 때문이다.

### Reference-counting 가비지 콜렉션

`Reference-counting` 알고리즘은 가장 소박한 알고리즘이다. 이 알고리즘은 더 이상 필요없는 오브젝트를 **다른 어떤 오브젝트도 참조하지 않는 오브젝트**라고 정의한다. 이를 가비지라고 부르며 GC에 의해 수집이 가능하다.

```jsx
// 객체는 참조 타입이므로 가비지 콜렉션의 대상이다.
var x = {
	a: {
		b: 2
	}
};

var y = x;
x = 1;	// y가 위 오브젝트를 참조하는 유일한 변수가 되었다

var z = y.a;	// y.a는 y와 z에 의해 참조된다
y = “mozilla”;	// y는 더 이상 위 객체를 참조하지 않는다. 다만 a 속성은 여전히 z에 의해 참조된다.

z = null;		// 이제 객체를 참조하는 변수는 없다. 객체에 대해 가비지 콜렉션이 수행된다.
```

### 순환 참조

`Reference-counting`은 순환 참조하는 두 객체를 회수하지 못한다.

```jsx
var x = {};
var y = {};
x.a = y;
y.a = x;
```

### Mark-and-sweep 알고리즘

이 알고리즘은 더 이상 필요없는 오브젝트를  **닿을 수 없는 오브젝트**로 정의한다. 이 알고리즘은 `roots`라는 오브젝트의 집합을 가지고 있으며 전역변수들을 의미한다. 가비지 콜렉터는 **주기적으로 roots로 부터 시작하여 roots가 참조하는 오브젝트들, roots가 참조한는 오브젝트가 참조하는 오브젝트들, …**을 닿을 수 있는 오브젝트라고 표시한다. 그리고 닿을 수 있는 오브젝트가 아닌 오브젝트에 대해 가비지 콜렉션을 수행한다.

이 알고리즘은 Reference-counting보다 효율적이다. 왜냐하면 `참조되지 않는 오브젝트`는 모두 `닿을 수 없는 오브젝트`이지만 역은 성립하지 않기 때문이다. 따라서 순환 참조의 메모리 누수 문제가 해결될 수 있게 되었다. 2012년 이후 모든 최신 브라우저들은 `Mark-and-sweep` 알고리즘을 사용하고 있다.

### Node.js의 경우

Node.js는 브라우저 환경에서 실행되는 Javascript에 사용할 수 없는 메모리 문제를 구성하고 디버깅하기 위한 추가 옵션과 도구를 제공한다.

```jsx
node —max-old-space-size=6000 index.js
node —expose-gc —inspect index.js
```

---

[1] MDN Web Docs, [http://developer.mozilla.org/ko/docs/Learn/](http://developer.mozilla.org/ko/docs/Learn/)