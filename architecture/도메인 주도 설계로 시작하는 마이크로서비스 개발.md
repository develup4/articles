# 아마존 비즈니스 민첩성의 비밀

## 성공한 인터넷 기업들과 비즈니스 민첩성

### **클라우드 인프라에 어울리는 애플리케이션의 조건**

- `Scale Up(수직 확장)` : 시스템 자체의 물리적 용량을 증가시켜 성능을 증가
- `Scale Out(수평 확장)` : 기존 시스템과 같은 다수의 장비를 병행 추가하여 가용성 증가

특정 서비스만 탄력성있게 확장이 가능하다. 예를 들어 타임 세일(Time Sale) 이벤트를 진행한다고 할 때, 해당 서비스만 Scale Out시키고 또한 종료 후에 줄일 수 있다.

- `Cloud Friendly Application` : 큰 하나의 덩어리로 클라우드 환경에 배포만 될 수 있는 하나의 애플리케이션
- `Cloud Native Application` : 독립적으로분리되어 배포될 수 있는 조각으로 구성된 애플리케이션으로 클라우드 인프라에 가장 어울리고 효과적이다. 궁극적으로는 모두 클라우드 네이티브로 전이해야한다.

## **마이크로서비스란 무엇인가?**

- 각 서비스가 독립적이어서 서로 다른 언어로 개발하는 것도 가능하므로 각 서비스의 소유권을 분리해 서로 다른 팀이 개발 및 운영할 수 있다.
- 각기 **저장소가 다르므로** 업무 단위로 모듈 경계가 명확하게 구분된다.

### **SOA와 마이크로서비스**

- 특정 서비스를 구축하는데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식을 가리켜 `Polyglot`하다고 표현한다.
- 과거 CBD/SOA 접근법에서는 애플리케이션은 모듈별로 분리했으나 데이터 저장소까지는 분리하지 못했다.
- 이론적으로 SOA와 MSA는 거의 동일할수도 있지만 전자가 이론으로만 남게된 이유는 각종 인프라(AWS와 같은)의 부재와 디테일(저장소의 분리) 때문이다.
- MSA에서는 두 가지 개념으로 모듈화 방식을 강화해서 실현하였다.
  - 서비스별 저장소를 분리해서 다른 서비스가 저장소를 직접 호출하지 못하도록 캡슐화한다. 즉, 다른 서비스의 저장소에 접근하는 수단은 API 밖에 없다.
  - REST API와 같은 가벼운 개방형 표준을 사용해 각 서비스가 느슨하게 연계되고 누구나 쉽게 사용할 수 있다.

## **마이크로서비스를 위한 조건은 무엇인가?**

### **조직의 변화: 업무 기능 중심 팀**

- 멜빈 콘웨이의 `Conway`s Law`
- 업무 기능 중심 팀은 다양한 역할(기획자, 디자이너, 프론트엔드 개발자, 백엔드 개발자, 설계자, 테스터)로 구성된다.
- 이를 다기능 팀(Cross-Functional Team)이나 two pizza team이라고도 부른다. 피자 두 판으로 서로 빈번히 의사소통하며 함께 식사할 수 있는 정도의 팀원 수를 의미한다.
- 애자일에 용이한 구성임을 알 수 있다. 뒤에도 나오겠지만 MSA는 단순히 아키텍쳐만을 의미하지는 않는다.

### **관리체계의 변화: 자율적인 분권 거버넌스, 폴리글랏**

- 아마존에서는 다기능 팀이 개발과 운영을 책임진다.

<aside>
💡 “you build it. you run it.”

</aside>

즉, DevOps 개념 또한 마이크로서비스와 뗄 수 없는 것이다.

### **개발 생명주기의 변화: 프로젝트가 아니라 제품 중심으로**

- 기존에는 대부분의 애플리케이션 개발 모델이 프로젝트 단위였다. 개발을 완료하고 나면 이를 운영조직에 넘기는 방식으로 진행됐다.
- 또한 초기에 모든 일정을 계획했다.
- 마이크로서비스팀의 개발은 비지니스의 갑작스런 트렌드 변화에 유연하게 대처해야하고 개발 뿐만 아니라 운영을 포함한 소프트웨어의 전체 생명주기를 책임져야 한다.
- 간단히 말해 애자일 개발방식이다.

### **개발 환경의 변화: 인프라 자동화**

- 최근에는 배포 환경이 마이크로서비스 개수에 따라 급격하게 늘어나기 때문에 이를 효율적으로 관리하기 위해 인프라 구성과 자동화를 마치 소프트웨어처럼 코드로 처리하는 방식인 `Intrastructure as Code`가 각광받고 있다.

### **저장소의 변화: 통합 저장소가 아닌 분권 데이터 관리**

- 단일 저장소 방식은 과거 스토리지 가격 및 네트워크 속도에 따른 데이터의 안정성과 효율성을 추구한 결과이다.
- 폴리글랏 저장소(polyglot persistence) 접근법을 위해서는 **비지니스 처리를 위해 일부 데이터의 복제와 중복 허용이 필요하다**
- 이를 위해 비지니스 정합성을 맞춰야하는 데이터 일관성 문제가 발생한다.
- 보통은 2단계 커밋(two-phase commit) 같은 분산 트랙잭션 기법을 사용하지만 저장소에 따라(NoSQL) 지원하지 않을수도 있다.
- 이런 경우에는 두 서비스를 단일 트랙잭션으로 묶는 방법이 아닌 비동기 이벤트 처리를 통한 협업을 강조한다. 이를 `결과적 일관성(Eventual Consistency)`라고 부른다.
- 여러 트랜잭션을 하나로 묶지 않고 별도의 로컬 트랜잭션을 수행한 뒤, 일관성이 달라진 부분은 체크해서 보상 트랜잭션으로 일관성을 맞추는 개념이다.

## **정리**

- MSA라는 용어를 문자 그대로 아키텍쳐나 기술로만 생각하는 경향이 있는데 이는 바람직하지 못하다.
- MSA는 다양한 사람들이 만나서 협업하는 방식, 조직 문화의 진화된 결과물로 생각해야 한다.

# MSA의 이해

## 리액티브 선언: 현대 애플리케이션이 갖춰야 할 바람직한 속성들

마이크로서비스 아키텍처는 클라우드라는 가상화된 인프라를 활용해서 구조화하는 것이기 때문에 가상화된 인프라의 특징을 고려해서 설계해야 한다.

- `응답성(Responsive)` : 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공하는 것을 의미한다.
- `탄력성(Resilent)` : 장애가 발생하거나 부분적으로 고장나더라도 시스템 전체가 고장나지 않고 빠르게 복구되는 능력을 의미한다.
- `유연성(Elastic)` : 시스템의 사용량에 변화가 있더라도 균일한 응답성을 제공하는 것을 의미하며, 시스템 사용량에 비례해서 자원을 늘리거나 줄이는 능력을 말한다.
- `메시지 기반(Message Driven)` : 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향하는 것을 의미한다.

## 강 결합에서 느슨한 결합의 이키텍처로의 변화

최근 아키텍처 설계 문서들을 보면 각 솔루션의 로고로 채워지는 경향이 있는데, 이것은 아키텍처링이 유연하고 호환성있는 적절한 솔루션 및 오픈소스를 선택하는 과정임을 보여준다.

## MSA 구성요소 및 패턴

### 인프라 구성요소

1. VM과 컨테이너

   마이크로 서비스같은 작은 서비스를 패키지하고 배포하기에는 컨테이너 환경이 더 적합하다. 가장 많이 사용하는 컨테이너 기술은 도커로 가장 유명하고 실질적인 표준으로 자리잡고 있다. 도커 컨테이너는 다음과 같은 이점이 있다.

   - 이식성 : 어떠한 호스트 커널이나 플랫폼 버전에 상관없이 도커만 실행할 수 있으면 사용 가능하며 동일하게 동작된다.
   - 신속성 : 크기가 작고 가볍기 때문에 빠르게 배포 가능하며, 문제 발생 시 수정할 필요없이 새로 기동하면 된다.
   - 재사용성 : 동일한 환경을 재사용해서 쉽게 설정 가능하기 때문에 개발, 테스트, 스테이징, 프로덕트 환경을 동일한 환경으로 구축하기 쉽다.

1. 컨테이너 오케스트레이션

   컨테이너를 관리하기 위한 기술을 컨테이너 `오케스트레이션(Container Orchestration)`이리 한다. 구글이 자사의 도커 컨테이너 관리 노하우를 CNCF 재단에 제공해서 공개한 `쿠버네티스(Kubernetes)`가 가장 인기있다. 쿠버네티스는 다음과 같은 주요 기능을 제공한다.

   - 자동화된 자원 배정(Automatic binpacking) : 각 컨테이너가 필요로 하는 CPU와 메모리를 쿠버네티스에 요청하면 컨테이너를 노드에 맞춰 자동으로 배치한다.
   - 셀프 치유(Self-healing) : 컨테이너의 이상 유무를 점검(Health-Check)해서 실패한 경우 자동으로 교체하고 재스케쥴링한다.
   - 수평 확장(Horizontal scaling) : 일정 CPU 및 메모리 사용량을 초과하면 자동으로 확장한다.

### 마이크로 서비스 운영과 관리를 위한 플랫폼 패턴

마틴 파울러도 강조했듯 MSA 시스템을 구성하는 수많은 마이크로서비스를 하나하나 수동으로 빌드하고 배포한다면 비효율적이고 큰 혼란을 가져올 것이기 때문에 이러한 과정을 하나하나 통제하고 자동화하는 것이 중요하다. 그래서 필요한 요소가 `데브옵스(DevOps)` 환경이다.

자동화된 빌드나 배포 작업을 보통 CI/CD라고 하며 CI는 `지속적 통합(Continuous Integration)`을 가리킨다. 지속적 통합은 애자일 방법론 중 켄트 벡이 만든 XP의 주요 프랙티스로 시작했으며, 오랜 시간이 걸리는 빌드를 매일 자동화해서 수행한다면 개발 생산성이나 소스코드 품질이 높아진다는 경험에서 출발했다.

1. 개발자들이 퇴근할 때 매일 자신이 작성한 소스코드와 그것을 테스트한 테스트 코드를 형상관리 시스템에 보낸다(Push).
2. 빌드 도구에서 매일 밤 형상관리 서버의 코드를 가져와(Pull) 통합한 다음, 자동으로 빌드하고 ㅔㅌ스트 코드를 실행해 테스트를 수행한다.
3. 테스트 수행 결과를 리포트 문서로 기록하고, 빌드된 소스코드를 스테이징 환경에 자동으로 배포한다.
4. 다음날 테스터가 스테이징 환경에서 테스트를 수행한다. 또는 빌드 및 단위 테스트 결과를 개발자가 확인하고 문제가 있따면 즉시 소스코드를 수정한다.

`지속적 제공(Continuous Delivery)`은 빌드된 소스코드의 실행파일을 실행 환경에 반영하기 전 단계까지 진행하는 방식이다. 따라서 아직 실행 환경에 배포되지 않았고 실행 환경에 반영하기 위해서는 승인 및 배포 담당자의 허가를 받아야 하며, 배포도 수동으로 처리한다. 다소 엄격한 배포 절차를 밟는다고 할 수 있다.

`지속적 배포(Continuous Deployment)`는 소스코드 저장소에서 빌드한 소스코드의 실행 파일을 실행 환경까지 자동으로 배포하는 방식을 말하며, 모든 영역을 자동화하는 것에 해당한다.

최근 클라우드같은 가상 환경에 대중화되면서 완전한 자동화가 가능해졌고, 인프라 구성을 마치 프로그래밍하는 것처럼 처리하고 소수의 인원으로 많은 컨테이너를 배포 처리할 수 있게 됐는데, 이를 가리켜 `Infrastructure as Code`라 한다.

마이크로 서비스는 각각 별도의 리포지토리를 가지고 있고 독립적으로 수정 및 빌드하고 배포해야 한다. 따라서 빌드/배포 파이프라인도 마이크로 서비스 별로 별도로 설계해야 한다.

### 마이크로서비스 생태계와 운영 관리 요소의 탄생

전체 서비스를 여러 개의 서비스로 분산 구성했을 때 한 서비스에서 발생한 장애가 다른 서비스로 전파된다거나 여러 서비스에 분산된 로그를 관리해야 하는 불편함, 서비스 하나가 동작하지 않아 시스템의 일부 기능이 동작하지 않아도 그것을 알아채지 못하고 장애가 방치되는 문제가 발생하였고, 넷플릭스 OSS에서 이러한 문제점들을 다룬 노하우를 담아 라우팅과 로드밸런싱을 위한 Zuul과 Ribbon, 모니터링을 위한 Hystrix, 서비스 등록을 위한 Eureka 등을 기부하였다. 이들을 스프링 프레임워크로 감싸서 스프링 클라우드(Spring Cloud)라는 이름으로 발표되었다.

1. 모든 마이크로서비스는 인프라에 종속되지 않도록 데이터베이스, 파일 등에 저장됟ㄴ 환경 설정 정보를 형상관리 시스템에 연계된 Config 서비스에서 가져와 설정 정보를 주입한 후 클라우드 인프라의 개별 인스턴스로 로딩된다.
2. 로딩과 동시에 서비스 레지스트리에 자신의 서비스명과 클라우드 인프라로부터 할당받은 물리 주소를 매핑해서 등록한다.
3. 클라이언트가 API 게이트웨이를 통해 마이크로서비스에 접근하고, 이때 API 게이트웨이는 적절한 라우팅 및 부하 관리를 위한 로드 밸런싱을 수행한다.
4. API 게이트웨이에서 클라이언트가 마이크로서비스에 접근하기 위한 주소를 알기 위해 서비스 레지스트리 검색을 통해 서비스의 위치를 가져온다.
5. 동시에 API 게이트웨이는 클라이언트가 각 서비스에 접근할 수 있는 권한이 있는지 권한 서비스와 연계해 인증/인가를 수행한다.
6. 이러한 모든 마이크로서비스 간의 호출 흐름은 모니터링 서비스와 추적서비스에 의해 모니터링되고 추적된다.

### 서비스 단일 집입을 위한 API 게이트웨이 패턴

- 레지스트리 서비스와 연계한 동적 라우팅, 로드 밸런싱
- 보안 : 권한 서비스와 연계한 인증/인가
- 로그 집계 서비스와 연계한 로깅(API 소비자 정보, 요청/응답 데이터 등)
- 메트릭(에러율, 평균/최고 지연시간, 호출 빈도 등)
- 트레이신 서비스와 연계한 서비스 추적(트래깅 ID 기록 등)
- 모니터링 서비스와 연계한 장애 격리(서킷 브레이커 패턴)

### 중앙화된 로그 수집 패턴

마이크로서비스에서 보낸 로그가 중앙 레디스에 쌓이면 `레디스`에서 중앙 관리 저장소에 로그를 보내고, 이 로그 저장소에 `엘라스틱서치` 엔진이 로그를 인덱싱하고 해당 로그 정보가 `키바나` 대시보드를 통해 보여진다. 중간에 레디스를 둔 까닭은 마이크로 서비스의 `로그스태시`가 바로 로그 저장소에 로그를 보낼 수 있지만 로그 스트림이 너무 몰리면 로그 저장소 서비스에도 성능 문제가 생기기 때문에 중간에 임시 저장소를 추가한 것이다.

### 서비스 메시 패턴

운영 관리를 위한 여러개의 기반 서비스(API 게이트웨이, 서비스 레지스트리, 컨피그 서비스 등)을 별도로 각각 만들어야 한다는 번거로움과 클라우드 서비스를 사용하기 위한 라이브러리를 비즈니스 로직과 함께 탑재해야 한다는 문제점이 있다.

이러한 문제 해결을 위해 비즈니스 로직과 분리해서 네트워크 인프라 계층에서 수행하게 하는 `서비스 메시(Service mesh) 패턴이 선호되고 있다. 서비스 메시 패턴의 대표적 구현체는 구글의 이스티오(Istio)가 있다.

### 저장소 분리 패턴

국내 엔터프라이즈 애플리케이션의 내부를 보면 모든 비즈니스 로직이 데이터베이스의 SQL 처리에 몰려있는 경우가 대부분이다. 이러한 구조를 데이터 중심 애플리케이션이라 하는데 이러한 구조는 아무리 여러개의 마이크로서비스로 분리하더라도 요청이 증가할 경우 서비스는 한가하고 통합 데이터베이스만 바쁜 상황이 벌어질 수 있다. 이를 보완하기 위해 마이크로서비스는 저장소 분리 패턴을 사용한다. 하지만 분산된 저장소에서 어떻게 비즈니스 정합성 및 데이터 일관성을 보장할 것인가?

### 분산 트랜잭션 처리 패턴

전통적인 방법으로는 `2단계 커밋`과 같은 기법을 사용할 수 있다. 이는 분산 데이터베이스 환경에서 원자성을 보장하기 위해 분산 트랜잭션에 포함되어 있는 모든 노드가 커밋(Commit)되거나 롤백(Rollback)되는 메커니즘이다. 하지만 이 방법은 Lock으로 인한 성능 문제로 사용되기 어렵고, MongoDB와 같은 NoSQL 저장소는 2단계 커밋 자체를 지원하지 않는다.

이를 해결하기 위한 패턴이 바로 `사가(Saga) 패턴`이다. 사가 패턴은 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴이다. 분산된 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 `보상 트랜잭션`을 이용해 비즈니스 및 데이터 정합성을 맞춘다. 그렇다면 다른 트랜잭션의 결과에 따라 롤백이 필요하다면 어떻게 해야 할까? 보상 트랜잭션을 활용한다. 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리게 하는 트랜잭션이다. 모든 비즈니스 처리가 반드시 실시간성을 요구하는 것은 아니다. 어떤 경우에는 `결과적 일관성(Eventual consistency)`만으로 충분한 경우도 있다.

### 읽기와 쓰기 분리 : CQRS패턴

시스템의 상태를 변경하는 명령과 시스템의 상태를 조회하는 부분이 있을 때 상태를 조회하는 부분이 많이 쓰인다. 이에 따른 차등 구조를 가지는 것이다.

### 쓰기 최적화 : 이벤트 소싱 패턴

이벤트 소싱(Event sourcing) 기법이란 트랜잭션 자체를 저장하는 전략이다. 명령들에 대한 스택과 같은 느낌이다.
