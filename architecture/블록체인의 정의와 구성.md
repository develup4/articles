# 블록체인이란?

정보를 `블록`이라고 하는 단위로 저장하여 저장된 블록 들을 `체인` 형태로 묶은 저장기술이다. 하지만 본질적으로는 중앙 운영 기관을 **협동조합화**한다는 것을 의미하며 거버넌스의 혁명이다. 핵심적인 개념인 탈중앙화 역시 데이터의 분산보다는 **이용자들이 서비스 운영에 참여**하고 **의견 충돌시 합의** 메커니즘을 통해 중재한다는 것에 의미가 있다.

# 블록체인 네트워크와 노드

- 블록체인은 한명 이상의 참여자가 있는 네트워크에서 관리한다.
- 네트워크 **참여자 전원은 모든 블록을 동일한 순서로 저장**하여 모두 같은 블록체인을 유지한다.

# 합의(Consensus)

- 자격이 있는 참여자는 블록을 제안(propose)할 수 있다.
- 블록 제안 자격은 네트워크마다 상이하다. 예를 들어 `자격 증명`, `자격 지분`과 같은 방식이 있다.
- 블록이 체인에 추가된다는 것은 **다른 모든 참여자들**이 새 블록을 자신의 체인에 추가한다는 의미이다.
- 노드들은 제안자가 올바른 자격을 취득했는지, 제안된 블록이 올바른지 **검증한** 뒤 블록을 자신의 체인에 추가한다.
- 정족수나 정해진 기준을 만족하는 수의 노드가 블록을 자신의 체인에 추가하면 합의가 이뤄졌다고 판단한다.

# 블록체인의 불변성과 투명성

- **어느 한 주체가 단독으로 결정하는 구조가 아닌, 여러 참여자가 합의를 통해 결정**하기 때문에 블록체인은 `탈중앙화`되어있다고 표현한다.
- 참여자 전원은 이전 블록들을 저장하고 있으므로 새로운 블록의 무결성을 확인이 가능하다.
- 새롭게 제안되는 블록은 참여자들이 검증 및 합의할 수 있는 형태여야한다. **(투명성)**
- 한번 쓰여진 블록은 이전의 합의를 번복할 수 있지 않는 한 변경될 수 없다. **(불변성)**

# PoS

개념이 Miner에서 Investor로 전환하는 것이다. 방식은 **내 체인이 맞다고 생각하면 돈을 걸어. 맞으면 인센티브를 주겠다. 틀리면 건 돈은 회수된다**라는 개념이다.

# Public 블록체인 vs Private 블록체인

`퍼블릭`과 `프라이빗`의 구분은 블록체인에 다음을 수행할 수 있는지 확인하여 결정한다.

- 누구든지 기록된 정보(블록)를 자유롭게 읽을 수 있는지?
- 명시적인 등록 또는 자격취득 없이 정보를 블록체인 네트워크에 기록할 수 있는지?

블록체인의 정보가 공개되어 있고 네트워크가 정한 기준, 예를 들어 가스피(Gas Fee)에 따라 정보를 기록요청 할 수 있다면 그 블록체인은 퍼블릭/공개형이라 한다. 이와 반대로 정보가 공개되어 있지 않고 미리 자격을 득한 사용자만이 정보를 기록할 수 있다면 그 블록체인은 프라이빗/비공개형이라 한다.

# Permissionless 블록체인 vs Permissioned 블록체인

Public / Private의 개념이 정보의 접근성(Access)와 관련이 있다면, **Permisionless / Permissioned**는 정보의 제어 (Control), 즉 **무엇이 블록에 포함되는지를 결정**하는 지에 더 연관된다.

# 블록체인과 공개키 암호

- 블록체인은 암호학적 기법을 토대로 만들어진 기술이다.
- Bitcoin은 네트워크 참여자 모두가 같은 `원장`을 공유함으로써 투명한 거래가 가능하다.
- 원장은 어느 주소에 BTC가 있는지 기록하지만 그 주소가 누구에게 속하는지는 기록하지 않는다. (Anonymity)
- Bitcoin은 공개키 암호를 사용하여 명시적인 비밀교환과정 없이 BTC의 소유권 증명을 실행 **(공개키는 쌍이 되는 비공개키에 의해서만 열린다는 대칭키의 원리 이용)**
- 누구든 해당 주소로 변환가능한 공개키로 검증가능한 서명을 생성할 수 있다면 그 주소의 제어권을 소유하고 있다고 가정한다.

# 구현 방법으로 나눠본 블록체인

- `UTXO(Unspent Transaction Output)` 기반 블록체인
  - 일반적인 자격검증방법은 UTXO의 정보와 일치하는 공개키로 검증가능한 전자서명을 제출하는 것이다.
  - Bitcoin이 대표적인 UTXO 기반 블록체인이다.
- `어카운트 기반` 블록체인(Account-based Blockchain)
  - 어카운트는 블록체인을 구성하는 주체(entity)를 표현하며 상태를 기록한다.
  - 사용자는 어카운트를 사용할 때마다 어카운트 공개키로 검증가능한 전자서명을 생성한다.
  - 상태를 기록할 수 있기 때문에 스마트 컨트랙트를 구현하기에 용이하다.
  - `Ethereum`, `Klaytn`이 대표적인 어카운트 기반 블록체인이다.

# Ethereum 어카운트, 주소, 상태

- Ethereum의 어카운트는 Ethereum의 주체(Entity)를 표현하고 그 상태를 기록하는데 사용한다.
- 어카운트는 `EOA(Externally Owned Account)`와 `스마트 컨트랙트`로 구분한다.
- Ethereum 사용자는 EOA를 사용한다.
- 사용자는 임의의 공개키와 비밀키 쌍(Key Pair)을 생성한뒤 공개키를 어카운트 주소로 변환하여 EOA를 생성한다.
  - 별도의 승인과정이 필요없으며 Ethereum 네트워크와 통신도 필요없다.
  - 위 과정으로 인해 어카운트는 특정 키페어에 종속된다.
- 사용자의 상태(State)는 어카운트 주소로 찾을 수 있는 블록체인 저장공간에 기록된다.

# 트랜잭션(Transaction, TX)

- **블록은 트랜잭션들을 일정한 순서로 정렬하여 저장**하는 컨테이너이다.
- 트랜잭션은 어카운트의 행동이다.
- 트랜잭션의 **순서가 중요**하다. TX_1 → TX_2으로 진행하는 것은 괜찮지만 TX_2 → TX_1로 진행하는 것은 불가능하다.
- 블록체인 참여자들은 블록을 검증할 때 트랜잭션들이 올바른 순서대로 정렬되었는지를 확인 후 합의한다.
- 각각의 트랜잭션들은 어카운트에 연결된 공개키로 검증가능한 서명을 포함

# Confirmation

- `Confirmation 숫자`는 트랜잭션이 블록에 포함된 이후 생성된 블록의 숫자이다.
  - 임의의 트랜잭션 T가 포함된 블록의 높이가 100, 현재 블록높이가 105라면 T의 Confirmation 숫자는 6이다.
- PoW를 사용하는 블록체인들은 Finality가 없기 때문에 Confirmation 숫자가 중요하다.

# Finality

- Finality란 블록의 `완결성`을 의미한다. **합의를 통해 생성된 블록이 번복되지 않을 경우 완결성**이 존재한다.
- PoW 기반 합의는 확률에 기반하기 때문에 경우에 따라 블록이 사라질 수 있으므로 완결성이 없다.
  - PoW 블록체인은 수학적으로 복잡한 퍼즐을 풀어 블록을 제안할 자격을 얻는 구조이다.
  - 만약 두명의 서로 다른 참여자가 **동시에** 퍼즐을 풀어 두 개의 올바른 블록을 생성한다면 두 블록 중 하나는 사라진다.
  - 이 때문에 블록이 확률적 완결성를 갖기까지 일정 갯수 이상의 블록이 생성되기를 기다려야 한다.
  - Bitcoin, Ethereum 모두 `Longest Chain`(또는 Heaviest Chain) 법칙을 사용한다.
- 네트워크 시차로 인해 생성된 우연한 복수의 블록들 가운데 하나가 선택되는데 필요한 블록은 두어개(2, 3 Confirmations) 정도이다. 퍼즐을 빠르게 풀 수 있는 악의적인 참여자(공격자)가 있을 경우 그 참여자의 해시능력(Hash Power)에 따라 필요한 Confirmation 숫자가 달라진다.
  - 해시능력이 높을수록 퍼즐을 푸는 속도도 빠르기 때문에 주어진 문제를 먼저 풀 확률이 높아진다.
  - 해시능력이 높은 참여자는 Longest Chain을 임의로 선택 또는 생성할 수 있다.
  - 따라서 해시능력을 감안하더라도 임의로 블록체인을 변경하지 못할 정도로 충분히 많은 블록이 생성되기를 기다려야할 필요가 생긴다.
  - Bitcoin의 6 Confirmation 법칙은 공격자가 전체 해시능력의 약 25%를 가질 때를 가정한 숫자이다.

# BFT(Byzantine Fault Tolerance) 기반 블록체인

- `BFT 기반` 블록체인은 **블록의 완결성이 보장**된다.
  - 네트워크가 동기화되어 있기 때문이다.
  - 블록 생성이 `PoW`에 비해 빠르고 경제적이다.
- 하지만 네트워크 동기화의 필요로 인해 참여자의 숫자가 제한된다.
  - 네트워크 참여자 구성이 고정되어 있어야 합의가 가능하다.
  - 구성이 변경될 경우 모든 네트워크 참여자가 새로운 구성을 인지하기 까지 합의가 불가능하다.
  - 합의 알고리즘이 네트워크 동기화를 가정하고 짜여졌기 때문에 네트워크 사용량이 높다.
  - 참여자가 많아질 경우 네트워크 오버헤드로 인해 합의가 느리다.

# **Account 기반의 블록체인 상태**

- 블록체인은 초기 상태에서 변경사항을 적용하여 최종 상태로 변화하는 상태 기계이다.
  - 이전 블록의 최종 상태(Final state)는 현재 블록의 초기 상태(Initial State)
  - Genesis Block의 경우 임의의 초기값들이 설정되는데 이것이 Genesis Block의 초기상태이자 최종상태이다.
- (어카운트 기반) 블록체인의 상태
  - 블록체인의 상태 = 블록들에 저장된 트랜잭션(TX)들을 순차적으로 실행하여 나온 결과이다.
  - TX는 어카운트를 생성하거나 변경한다.
  - Alice가 기존에 존재하지 않던 주소 X에 1 ETH를 전송하면 새로운 EOA가 생성된다.
  - Alice가 새로운 스마트 컨트랙트를 생성/배포하면 새로운 스마트 컨트랙트가 블록체인에 추가된다.
  - Alice가 Bob에게 5 ETH를 전송하는 TX가 체결되면 Alice의 Bob의 잔고가 변경된다.
  - 항상 같은 결과를 보장하기 위해 하나의 TX가 반영되는 과정에서 다른 TX의 개입은 제한된다.

# **Ethereum 어카운트의 종류**

1. `External Account`: 사용자(End User)가 사용하는 어카운트 (a.k.a EOA)
2. `Contract Account`: 스마트 컨트랙트를 표현하는 어카운트

- Ethereum은 EOA와 스마트 컨트랙트의 상태를 기록 및 유지
  - 스마트 컨트랙트는 **특정주소에 존재하는 실행 가능한 프로그램**이다.
  - **프로그램은 상태를 가지기 때문에** Ethereum / Klaytn은 스마트 컨트랙트를 어카운트로 표현한다.
- EOA는 블록에 기록되는 TX를 생성한다.
  - 블록에 기록되는 TX들은 명시적인 변경을 일으킨다. (ex: 토큰 전송, 스마트 컨트랙트 배포 및 실행)

# **트랜잭션(TX)과 가스(Gas)**

- TX의 목적은 **블록체인의 상태를 변경**하는 것
  - TX는 **보내는 사람**(sender, from)과 **받는 사람**(recipient, to)이 지정되어 있으며, to가 누구냐에 따라 TX의 목적이 세분화된다.
  - Gas: TX를 처리하는데 발생하는 비용
  - TX를 처리하는데 필요한 자원(Computing power, Storage)을 비용으로 전환한 것이 가스(Gas)다.
  - Sender는 TX의 처리를 위해 필요한 가스의 총량과 같은 가치의 플랫폼 토큰을 제공해야한다.
  - 이때 지출되는 플랫폼 토큰을 `가스비(Gas Fee)`라 정의하며 가스비는 블록을 생성한 노드가 수집한다.

# **트랜잭션과 서명**

- 플랫폼은 Sender가 TX가 처리되는데 필요한 가스비를 가지고 있는지 확인한다.
  - 가스비 확인은 구현에 따라 상이하다.
  - Ethereum / Klaytn은 노드가 TX를 수신함과 동시에 가스비 이상의 balance가 있는지 확인한다.
  - TX의 체결과 동시에 sender의 balance에서 가스비를 차감한다.
- TX는 sender의 **서명(v, r, s)**이 필요하다.

  - 어카운트의 balance를 사용하기 때문
  - 서명의 증명은 구현마다 상이하다.
  - Ethereum: 서명 → 공개키 도출 → 어카운트 주소 도출 → 어카운트 존재 유무 확인
  - Klaytn: from 주소 확인 → 저장된 공개키 불러오기 → 서명직접 검증

- 트랜잭션의 예시

```json
{
	nonce: 1,
	from: ‘0xd0ea3e0eabaea095ea3ba231c043dbf8c0feb40a’,
	to: ‘0x5e47b195eeb11d72f5e1d27aebb6d341f1a9bedb’, value: 10,
	// omitted other fields for brevity
	// platform specific fields are required
}
```

- Ethereum 트랜잭션 예시

```json
{
  "nonce": "0x01",
  "gasPrice": "0x4a817c800",
  "gas": "0x5208",
  "value": "0xde0b6b3a7640000",
  "to": "0x3535353535353535353535353535353535353535",
  // v, r, s는 서명이다. 서명을 통해 from을 알아내는데, 이것이 Ethereum 부하의 30%라고 한다.
  "v": "0x25",
  "r": "0x4f4c17305743700648bc4f6cd3038ec6f6af0df73e31757007b7f59df7bee88d",
  "s": "0x7e1941b264348e80c78c4027afc65a87b0a5e43e86742b8ca0823584c6788fd0"
  // some fields are omitted for brevity
}
```

# **이더리움**

비트코인은 블록체인에 화폐 거래내역만 저장하는 반면, 이더리움은 블록체인에 **프로그램의 코드** 또한 저장되도록 만들어져 있다. 그 코드를 **스마트 컨트랙트**라고 한다. 이더리움은 중앙 서버에서 프로그램이 실행하는 것이 서버의 정보 수집, 셧다운 문제, 검색어 순위 조작과 같은 결과 조작 문제의 원인이라고 보고 분산 실행 환경을 구성하였다. 이를 통해 중단되거나 변경되지 않는 앱, 데이터가 영원히 보관되는 앱을 만들 수 있게 되었다.

# **EVM**

## **블록체인을 컴퓨터로 '스마트계약'**

더 정확히 말하면, 이더리움은 자바(Java)처럼 `EVM(Ethereum Virtual Machine)`이라는 가상머신이 설치돼 있으며, EVM 위에서 프로그램 코드가 실행된다. 사용자의 컴퓨터에서 스마트계약 코드가 실행되고, 이 결과는 다시 블록체인에 저장⸱공유되기 때문에 다른 사용자가 이전의 작업을 계속 이어서 수행하는 것이 가능하다.

예를 들어 인터넷 포털사이트에서 제공하는 계산기 서비스를 이용한다고 상상해 보자. 1부터 10까지 더한다고 할 경우 '1+2+3+4+5+6+7+8+9+10'을 입력하면, 서버의 계산기 프로그램은 총합 55를 계산해 사용자 PC로 보내준다. 만일 계산 과정상의 오류 또는 서버 관리자의 의도적인 조작에 의해 오답이 발생했다면, 우리는 이를 어떻게 알 수 있을까? 포털사이트가 제공하는 계산기 서비스를 이용하지 않고 탈중앙화된 방식으로 총합을 정확히 계산할 방법은 없을까? 불가능할 것 같지만, 이더리움의 스마트 계약을 이용하면 간단하다.

우선 '1+2+3+4+5+6+7+8+9+10'을 계산하는 프로그램 코드를 만든 후, 이를 이더리움 블록체인에 등록한다. 이때 각각의 덧셈 연산에는 암호화폐로 보상금(일명 가스(gas))이 걸려있어서, 해당 연산을 가장 먼저 수행하는 사람이 보상금을 갖게 된다. 이 프로그램은 블록체인이 갖는 투명성으로 인해 이더리움 사용자라면 누구든 볼 수 있으며, 일단 한번 공표된 보상금은 불변성으로 인해 무효화 될 수 없다. 프로그램 개발자와 이더리움 사용자 사이에 일종의 계약 관계가 성립되는 것이다. 만일 이더리움 사용자 중 A가 가장 먼저 1+2를 실행했다면, 보상금은 A의 전자지갑으로 보내지게 되고 중간 결괏값 3은 블록체인상에 저장⸱공유된다. 이어서 사용자 B가 가장 먼저 직전의 중간 결괏값 3에 3을 더해 6을 계산한 후 이를 블록체인에 저장했다면 두 번째 현상금은 B에게 돌아간다. 계속해서 다음번 보상금 수령자는 중간값 6에 4를 더한 결과를 가장 먼저 계산해 낸 사람이 되며, 이 과정은 최종 10이 더해질 때까지 반복된다. 이때 계산이 제대로 이루어져 올바른 중간값이 도출됐는지 여부는 구성원들의 투표를 통해 결정된다. 만일 내 프로그램이 더 빨리 수행되기를 원한다면 더 많은 보상금을 걸면 된다.

## **이더리움, 월드 컴퓨터를 향한 질주**

구글과 애플이 직접 스마트폰 앱을 만들지 않고 구글 플레이 스토어나 애플 앱 스토어를 통해 다른 개발자들이 자신이 만든 앱을 업로드 할 수 있는 공간만을 제공하듯, 이더리움은 사람들이 개발한 스마트 계약 프로그램을 올릴 수 있는 공간을 제공한다. 바로 이러한 이유로 이더리움은 비트코인과 같이 단순한 화폐가 아니라 '화폐인 동시에 플랫폼', '다른 코인의 개발을 도와주는 코인', '월드 컴퓨터(the world computer)' 등으로 불리며, 혹자는 비트코인을 '황금'에, 이더리움을 '석유'에 비유하기도 한다.

지난 8월5일 '런던'으로 명명된 하드포크(hard fork)가 진행됐다. 이번 런던 하드포크는 스마트계약 보상금인 '가스비' 최적화에 역점을 뒀다. 이는 최근 'NFT(Non-Fungible Token, 대체불가능토큰)', '탈중앙화금융(DeFi, 디파이)' 등이 화제가 되면서 이더리움 생태계가 급성장했고, 가스비가 폭등했기 때문이다. 과도한 가스비 지불 경쟁은 결국 사용성 악화로 이어질 수 있어서 이더리움에서는 이번 런던 하드포크를 통해 표준 가스비를 만들어 수수료 부담을 줄이고 거래가 보다 더 활성화될 수 있도록 했다.

플랫폼(platform)이란 단어가 일반 대중에게 친숙해진 것은 꽤 오래다. 애플이 앱스토어라는 혁신적 플랫폼을 통해 몇몇 대형 통신 사업자에 의해 좌지우지되던 기존 이동통신 시장에 지각변동을 일으켰듯, 암호화폐계의 앱 스토어라 할 수 있는 이더리움도 엄청난 잠재력이 있다. 이것이 바로 우리가 비트코인보다 이더리움에 훨씬 더 많은 관심을 가져야 하는 이유다.

# **스마트 컨트랙트**

- 특정 주소에 배포되어있는 **Transaction으로 실행 가능**한 코드이다.
  - 스마트 컨트랙트 소스코드는 함수와 상태를 표현한다.
  - 컨트랙트는 어카운트로 취급된다. 또한 컨트랙트 소스코드는 블록체인에 저장된다.
  - 함수는 상태를 변경하는 함수, 상태를 변경하지 않는 함수로 분류된다.
  - 스마트 컨트랙트는 어카운트이기 때문에 주소를 부여한다.
  - 사용자(End User)가 스마트 컨트랙트 함수를 실행하거나 상태를 읽을 때는 주소가 필요하다.
- 스마트 컨트랙트는 사용자가 실행한다.
  - 상태를 변경하는 함수를 실행하려면 그에 맞는 TX를 생성해 블록에 추가해야한다. 즉, TX 체결은 함수의 실행을 의미한다.
  - 상태를 변경하지 않는 함수, 상태를 읽는 행위에는 TX가 필요없다. 즉, 노드에서만 실행된다.

---

[1] 인프런, K[laytn 클레이튼 스마트계약과 탈중앙앱](https://www.inflearn.com/course/klaytn-%EC%8A%A4%EB%A7%88%ED%8A%B8%EA%B3%84%EC%95%BD%EA%B3%BC-%ED%83%88%EC%A4%91%EC%95%99%EC%95%B1)

[2] 암호인, [이더리움이 월드 컴퓨터라 불리는 이유](https://blog.naver.com/amhoin/222465109408)
